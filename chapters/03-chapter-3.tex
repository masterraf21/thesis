\chapter{Analisis Masalah dan Perancangan Solusi Visualisasi \textit{distributed tracing}}

%Pada bab ini diuraikan analisis persoalan pengumpulan data pada \textit{spreadsheet} yang telah diuraikan pada Bab I. Hasil dari bab ini digunakan untuk merancang kakas yang akan diimplementasikan seperti yang dijelaskan pada Bab IV.
%Berdasarkan 


\section{Analisis Masalah}

 Pada masa sebelum adopsi arsitektur Microservice dan kebanyakan dari aplikasi masih menggunakan arsitektur Monolith, proses seperti \textit{debugging} adalah hal yang sederhana sebab jika terdapat suatu \textit{error} akan mudah untuk ditelusuri dari mana asal \textit{error} tersebut sebab hanya ada satu aplikasi yang digunakan. Hal tersebut tidak berlaku jika aplikasi menggunakan model Sistem Terdistribusi, salah satu contohnya adalah Microservice. Sifat dari Microservice yang melakukan \textit{decoupling} aplikasi menjadi bagian yang lebih kecil membuat proses \textit{debugging} menjadi tidak mudah sebab untuk mencari penyebab \textit{error} aplikasi yang terdistribusi, kita harus mengetahui terlebih dahulu sumber dari \textit{error} tersebut. Kompleksitas akan bertambah dalam proses debugging jika ternyata ditemukan bahwa sautu \textit{error} pada sebuah \textit{service} bukanlah akar atau penyebab utama dari \textit{error} tersebut melainkan suatu \textit{service} lainnya. Kompleksitas akan bertambah jika metode \textit{debugging} yang digunakan mengharuskan \textit{developer} yang menangani \textit{error} tersebut harus menelusuri satu per satu \textit{service} yang terdampak sampai menemukan akar dari masalahnya. Dari masalah tersebutlah timbul suatu kebutuhan untuk mendapatkan gambaran mengenai \textit{state} sebuah Sistem Terdistribusi ataupun yang disebut juga dengan \textit{observability}.
 
 Menurut \citep{sridharan2018distributed}, ada tiga pilar untuk mencapai \textit{observability} pada sebuah sistem terdistribusi, yaitu melalui \textit{log}, \textit{metric}, dan \textit{trace}. \textit{Log} atau \textit{event log} adalah suatu catatan yang bersifat \textit{immutable} dari \textit{event} yang terjadi sepanjang waktu. Sebuah \textit{event log} pada umumnya terdiri dari informasi mengenai \textit{timestamp} dan \textit{payload} yang berisikan konteks. \textit{Metric} dan \textit{trace} merupakan abstraksi yang dibuat di atas \textit{log} yang melakukan pra-pemrosesan dan melakukan dekode informasi berdasarkan dua sumbu, yang satu bersifat \textit{request} sentris yaitu \textit{trace}, dan yang lainnya bersifat sistem sentris yaitu \textit{metric}.
 
 
 Dengan bantuan dari \textit{trace} atau yang disebut \textit{distributed tracing}, \textit{developer} bisa mendapatkan suatu gambaran dari masing-masing \textit{request} yang terjadi pada sebuah \textit{resource} atau komponen yang berinteraksi dengan komponen lainnya dalam sebuah Sistem Terdistribusi seperti \textit{node}, \textit{service}, \textit{network}, ataupun \textit{mutex}. Ide dasar dari \textit{tracing} seperti yang sudah dijelaskan pada \ref{bab2-dtracing} adalah dengan mengidentifikasi sebuah titik spesifik, dapat jadi sebuah pemanggilan \textit{remote procedure call} (RPC), dalam sebuah aplikasi, \textit{library}, ataupun \textit{middleware} dalam jalur sebuah \textit{request} yang merepresentasikan kedua hal berikut:
 \begin{enumerate}
 \item \textit{Fork} pada eksekusi di level Sistem Operasi
 \item Sebuah lompatan atau akses horizontal ke luar melalui jaringan
\end{enumerate}

Data hasil \textit{trace} yang berisi kumpulan \textit{span} kemudian direpresentasikan sebagai \textit{directed acylic graph} (DAG), yang mana \textit{edge} antar graf dalam DAG yang disebut dengan \textit{reference} merepresentasikan hubungan atau kausalitas antar komponen dalam sebuah \textit{cluster} sistem terdistribusi yang terjadi pada \textit{request}. 

Pada akhirnya \textit{observability} hanya memiliki dua tujuan utama menurut \citep{parker2020distributed}, yaitu:
\begin{enumerate}
	\item Meningkatkan performa \textit{baseline} pada sistem
	\item Mengembalikan performa \textit{baseline} setelah terjadi regresi pada sistem
\end{enumerate}

Dengan meningkatkan performa \textit{baseline} pada sistem, para \textit{developer} berharap dapat meningkatkan kepuasan pelanggan, menurunkan biaya infrastruktur, ataupun keduanya. Untuk aplikasi yang langsung melayani pelanggan, performa seringkali berarti \textit{latency} dari \textit{request}. Proses optimisasi seperti ini biasanya adalah proses bertahap yang membutuhkan waktu.

Kakas yang digunakan untuk membantu mencapai \textit{observability} penting untuk meningkatkan performa \textit{baseline} dengan pertama kali mengukur performa awal yang menjadi \textit{baseline} pengukuran dan digunakan untuk mengarahkan para \textit{developer} agar dapat mencari bagian mana dari aplikasi yang dapat ditingkatkan performanya. Dengan aplikasi yang menggunakan arsitektur Monolith, para \textit{developer} dapat dengan mudah melakukan \textit{profiling} proses mana saja yang dapat ditingkatkan penggunaan \textit{resource}-nya seperti CPU ataupun Memory. Namun dengan penggunaan arsitektur Microservice yang berbasis sistem terdistribusi, terkadang sulit untuk mengetahui \textit{service} manakah yang tepatnya perlu ditingkatkan penggunaan \textit{resource}-nya, sehingga penggunaan \textit{distributed tracing} akan sangat membantu untuk meningkatkan performa \textit{baseline} dari sebuah sistem terdistribusi.

Berbeda dengan tujuan untuk meningkatkan performa \textit{baseline}, tujuan lainnya yaitu untuk mengembalikan performa \textit{baseline} bukanlah suatu hal yang dapat begitu saja direncanakan. Regresi dalam performa dapat muncul tiba-tiba seperti terjadinya \textit{outtage} atau pemberhentian tiba-tiba dari sebuah \textit{cluster} sistem terdistribusi. Melihat sifat dari sistem terdistribusi, mencari penyebab utama dari sebuah \textit{outtage} bukanlah sebuah hal yang mudah terlebih jika ada ratusan bahkan ribuan \textit{node} yang terdapat pada \textit{cluster} dan masing-masing \textit{node} saling terhubung dengan yang lainnya. Jika hal semacam tersebut terjadi dalam lingkungan aplikasi \textit{production} maka dampaknya akan terasa langsung oleh pelanggan dan dalam jangka panjang dapat menimbulkan kerugian material. Oleh karena itu, penting untuk segera mengetahui sumber atau akar dari suatu kejadian yang menyebabkan regresi pada performa sistem.

Dari solusi \textit{distributed tracing} bersifat \textit{open source} yang tersedia saat ini, Zipkin dan Jaeger adalah dua solusi \textit{tracing} yang sudah menyediakan komponen instrumentasi, \textit{deployment}, dan \textit{value delivery} dalam bentuk \textit{application programming interface} (API) dan \textit{user interface} secara \textit{default}. Berikut adalah tabel perbandingan dari fitur \textit{user interface} web Zipkin dan Jaeger.


\begin{small}
	\begin{longtable}{ | p{3.75cm} | p{5.5cm} | p{5.5cm} | }
		\caption{Deskripsi Perbandingan fitur Zipkin dan Jaeger}
		\label{jzipkin-comparison}                                                                                                                \\ \hline
		 & \centering\bfseries{Jaeger \citep{jaeger}} & \centering\bfseries{Zipkin \citep{zipkin}} \tabularnewline \hline
		\endfirsthead
		\bfseries{Deskripsi Singkat} & Dirilis sebagai kakas \textit{open-source} oleh Uber Technologies. Jaeger digunakan untuk melakukan \textit{monitoring} dan \textit{troubleshoot} dari sistem terdistribusi yang berbasis Microservice & Membantu mengumpulkan data bersifat temporal yang dibutuhkan untuk melakukan \textit{troubleshoot} permasalahn \textit{latency} pada aplikasi Microservice. Zipkin mengatur pengoleksian dan juga pencarian data. Desain dari Zipkin dibuat berdasarkan \textit{paper} dari Daper \citep{dapper-paper}\\ \hline
		\bfseries{Kelebihan} &  \textit{Open-source}; 
		Siap digunakan dengan Docker; Antarmuka dari \textit{collector} cocok digunakan dengan protokol milik Zipkin; Tingkat \textit{sampling} yang bersifat dinamis; Memiliki antarmuka berbasis Web &  \textit{Open-source}; 
		Siap digunakan dengan Docker; Dapat menggunakan teknologi transport bagi \textit{span} yang berbeda-beda (HTTP, Kafka, Scribe, AMQP); Memiliki antar muka berbasis Web  \\ \hline
		\bfseries{Kekurangan} & Hanya mendukung dua teknologi transport untuk \textit{span} (Thrift dan HTTP) & Tingkat \textit{sampling} yang bersifat \textit{fixed} \\ \hline
		\bfseries{Jenis Analisis tersedia} & Visualisasi graf dependensi; Perbandingan hasil \textit{trace} & Visualisasi graf dependensi \\ \hline
	\end{longtable}
\end{small}

Dari pemaparan mengenai kedua tujuan dari \textit{observability} di atas dan berdasarkan studi terhadap solusi \textit{open-source} yang sudah ada, penulis menyimpulkan bahwa ada dua hal yang dapat dibuat dengan menggunakan \textit{distributed tracing} untuk mencapai kedua tujuan utama dari \textit{observability}:
\begin{enumerate}
	\item Membuat Service Map untuk mencapai tujuan pertama yaitu meningkatkan performa baseline
	\item Membuat perangkat untuk melakukan Root Cause Analysis (RCA) untuk mencapai tujuan kedua yaitu mengembalikan performa baseline ketika terjadi regresi pada sistem
\end{enumerate}

Service Map merupakan visualisasi dari sebuah sistem Microservice yang melakukan dekomposisi pada semua komponen \textit{service} dan menggambarkan dependensi yang terlihat antar \textit{service} tersebut secara \textit{real-time}, sehingga \textit{developer} dapat mengidentifikasi \textit{bottleneck} yang ada dan memahami bagaimana data mengalir dalam aristektur \citep{datadog-svcmap}. Untuk dapat membantu meningkatkan performa \textit{baseline}, sebuah Service Map harus dapat menyediakan informasi mengenai hubungan interdependensi antara \textit{service}, jumlah \textit{request} yang diterima oleh service per satuan waktu, dan ukuran performa pada \textit{service} tersebut dalam merespon \textit{service} lainnya. Ukuran performa yang dapat dijadikan \textit{baseline} antara lain adalah \textit{latency}, \textit{failure rate}, \textit{traffic rate}, dan saturasi, namun biasanya \textit{developer} hanya berfokus pada pengukuran \textit{latency} dan \textit{failure rate} \citep{parker2020distributed}.

Selain digunakan untuk mendapatkan gambaran mengenai komponen yang ada pada suatu \textit{cluster} sistem terdistribusi, salah satu pendekatan yang dapat digunakan oleh Service Map untuk meningkatkan performa \textit{baseline}  disebut \textit{Correlation Analysis}.

Di sisi lain, kakas untuk melakukan Root Cause Analysis dapat digunakan untuk memberikan petunjuk kepada \textit{developer} mengenai komponen mana dari Microservice yang mengalami regresi sehingga \textit{developer} dapat mengatasi permasalahan tersebut dengan segera. Salah satu pendekatan yang bisa dilakukan untuk mengembalikan performa adalah dengan pendekatan \textit{Aggregate and Correlation Root Cause Analysis}. Tidak jauh berbeda dengan pendekatan yang telah terlebih dahulu disebutkan pada Service Map, pendekatan ini menggunakan agregasi dari beberapa \textit{trace} untuk mendapatkan koefisien korelasi mengenai keadaan performa sebuah \textit{service}. 

Adapun dari pemaparan di atas mengenai fitur analisis \textit{distributed tracing}, penulis menyimpulkan kebutuhan fungsional apa saja yang diperlukan pada pembuatan kakas visualisasi \textit{distributed tracing}:

\begin{small}
	\begin{longtable}{ | p{2cm} | p{10cm} | }
		\caption{Kebutuhan Fungsional kakas visualisasi}
		\label{fr-vis}                                                                                                                     \\ \hline
		\centering\bfseries{ID} & \centering\bfseries{Deskripsi} \tabularnewline \hline
		\endfirsthead
		\hline
		\centering\bfseries{ID} & \centering\bfseries{Deskripsi} \tabularnewline \hline
		\endhead
		UC-01                   & Pengguna dapat menentukan basis data tujuan dengan konfigurasi basis data yang diinginkan.                          \\ \hline
		UC-02                   & Pengguna dapat menyimpan data yang dikumpulkan ke dalam basis data pada saat dibutuhkan.                            \\ \hline
		UC-03                   & Pengguna dapat mendefinisikan \textit{metadata table} yang ingin disimpan secara manual maupun otomatis oleh kakas. \\ \hline
		UC-04                   & Pengguna dapat mengubah metadata pada \textit{metadata table} yang ingin disimpan.                                  \\ \hline
		UC-05                   & Pengguna dapat mendefinisikan aturan validasi data.                                                                 \\ \hline
		UC-06                   & Pengguna dapat mengunggah berkas \textit{spreadsheet} ke dalam aplikasi.                                            \\ \hline
	\end{longtable}
\end{small}






%Untuk mencapai kedua tujuan dari \textit{observability} tersebut, \textit{distributed tracing} dapat digunakan untuk menyediakan hal-hal berikut:
%\begin{enumerate}
%	\item 
%\end{enumerate}



%Seiring dengan meningkatnya penggunaan arsitektur, mengingkat pula kebutuhan bagi para \textit{developer} untuk dapat dengan segera mengetahui sumber dari permasalahan jika terjadi \textit{error} pada sistem.
%
%Dari pemaparan mengenai masih kurangnya kakas visualisasi \textit{tracing} yang bersifat \textit{open source}
%. Berdasarkan studi literatur mengenai \textit{observability} untuk Sistem Terdistribusi pada \ref{bab2-observability}, terdapat 

%Isu visualisasi 
%Overhead


%\section{Analisis Alternatif Solusi}
%Hewo
%
%\section{Rancangan Solusi}
%
%Hewoooo
%
%\section{Rancangan Perhitugan \textit{Overhead}}

%Overhead disini

