\chapter{Analisis Masalah dan Perancangan Solusi Visualisasi \textit{distributed tracing}}

%Pada bab ini diuraikan analisis persoalan pengumpulan data pada \textit{spreadsheet} yang telah diuraikan pada Bab I. Hasil dari bab ini digunakan untuk merancang kakas yang akan diimplementasikan seperti yang dijelaskan pada Bab IV.
%Berdasarkan 


\section{Analisis Masalah}

 Pada masa sebelum adopsi arsitektur Microservice dan kebanyakan dari aplikasi masih menggunakan arsitektur Monolith, proses seperti \textit{debugging} adalah hal yang sederhana sebab jika terdapat suatu \textit{error} akan mudah untuk ditelusuri dari mana asal \textit{error} tersebut sebab hanya ada satu aplikasi yang digunakan. Hal tersebut tidak berlaku jika aplikasi menggunakan model Sistem Terdistribusi, salah satu contohnya adalah Microservice. Sifat dari Microservice yang melakukan \textit{decoupling} aplikasi menjadi bagian yang lebih kecil membuat proses \textit{debugging} menjadi tidak mudah sebab untuk mencari penyebab \textit{error} aplikasi yang terdistribusi, kita harus mengetahui terlebih dahulu sumber dari \textit{error} tersebut. Kompleksitas akan bertambah dalam proses debugging jika ternyata ditemukan bahwa sautu \textit{error} pada sebuah \textit{service} bukanlah akar atau penyebab utama dari \textit{error} tersebut melainkan suatu \textit{service} lainnya. Kompleksitas akan bertambah jika metode \textit{debugging} yang digunakan mengharuskan \textit{developer} yang menangani \textit{error} tersebut harus menelusuri satu per satu \textit{service} yang terdampak sampai menemukan akar dari masalahnya. Dari masalah tersebutlah timbul suatu kebutuhan untuk mendapatkan gambaran mengenai \textit{state} sebuah Sistem Terdistribusi ataupun yang disebut juga dengan \textit{observability}.
 
 Menurut \citep{sridharan2018distributed}, ada tiga pilar untuk mencapai \textit{observability} pada sebuah sistem terdistribusi, yaitu melalui \textit{log}, \textit{metric}, dan \textit{trace}. \textit{Log} atau \textit{event log} adalah suatu catatan yang bersifat \textit{immutable} dari \textit{event} yang terjadi sepanjang waktu. Sebuah \textit{event log} pada umumnya terdiri dari informasi mengenai \textit{timestamp} dan \textit{payload} yang berisikan konteks. \textit{Metric} dan \textit{trace} merupakan abstraksi yang dibuat di atas \textit{log} yang melakukan pra-pemrosesan dan melakukan dekode informasi berdasarkan dua sumbu, yang satu bersifat \textit{request} sentris yaitu \textit{trace}, dan yang lainnya bersifat sistem sentris yaitu \textit{metric}.
 
 
 Dengan bantuan dari \textit{trace} atau yang disebut \textit{distributed tracing}, \textit{developer} bisa mendapatkan suatu gambaran dari masing-masing \textit{request} yang terjadi pada sebuah \textit{resource} atau komponen yang berinteraksi dengan komponen lainnya dalam sebuah Sistem Terdistribusi seperti \textit{node}, \textit{service}, \textit{network}, ataupun \textit{mutex}. Ide dasar dari \textit{tracing} seperti yang sudah dijelaskan pada \ref{bab2-dtracing} adalah dengan mengidentifikasi sebuah titik spesifik, dapat jadi sebuah pemanggilan \textit{remote procedure call} (RPC), dalam sebuah aplikasi, \textit{library}, ataupun \textit{middleware} dalam jalur sebuah \textit{request} yang merepresentasikan kedua hal berikut:
 \begin{enumerate}
 \item \textit{Fork} pada eksekusi di level Sistem Operasi
 \item Sebuah lompatan atau akses horizontal ke luar melalui jaringan
\end{enumerate}

Data hasil \textit{trace} yang berisi kumpulan \textit{span} kemudian direpresentasikan sebagai \textit{directed acylic graph} (DAG), yang mana \textit{edge} antar graf dalam DAG yang disebut dengan \textit{reference} merepresentasikan hubungan atau kausalitas antar komponen dalam sebuah \textit{cluster} sistem terdistribusi yang terjadi pada \textit{request}. 

Pada akhirnya \textit{observability} hanya memiliki dua tujuan utama menurut \citep{parker2020distributed}, yaitu:
\begin{enumerate}
	\item Meningkatkan performa \textit{baseline} pada sistem
	\item Mengembalikan performa \textit{baseline} setelah terjadi regresi pada sistem
\end{enumerate}

Dengan meningkatkan performa \textit{baseline} pada sistem, para \textit{developer} berharap dapat meningkatkan kepuasan pelanggan, menurunkan biaya infrastruktur, ataupun keduanya. Untuk aplikasi yang langsung melayani pelanggan, performa seringkali berarti \textit{latency} dari \textit{request}. Proses optimisasi seperti ini biasanya adalah proses bertahap yang membutuhkan waktu.

Kakas yang digunakan untuk membantu mencapai \textit{observability} penting untuk meningkatkan performa \textit{baseline} dengan pertama kali mengukur performa awal yang menjadi \textit{baseline} pengukuran dan digunakan untuk mengarahkan para \textit{developer} agar dapat mencari bagian mana dari aplikasi yang dapat ditingkatkan performanya. Dengan aplikasi yang menggunakan arsitektur Monolith, para \textit{developer} dapat dengan mudah melakukan \textit{profiling} proses mana saja yang dapat ditingkatkan penggunaan \textit{resource}-nya seperti CPU ataupun Memory. Namun dengan penggunaan arsitektur Microservice yang berbasis sistem terdistribusi, terkadang sulit untuk mengetahui \textit{service} manakah yang tepatnya perlu ditingkatkan penggunaan \textit{resource}-nya, sehingga penggunaan \textit{distributed tracing} akan sangat membantu untuk meningkatkan performa \textit{baseline} dari sebuah sistem terdistribusi.

Berbeda dengan tujuan untuk meningkatkan performa \textit{baseline}, tujuan lainnya yaitu untuk mengembalikan performa \textit{baseline} bukanlah suatu hal yang dapat begitu saja direncanakan. Regresi dalam performa dapat muncul tiba-tiba seperti terjadinya \textit{outtage} atau pemberhentian tiba-tiba dari sebuah \textit{cluster} sistem terdistribusi. Melihat sifat dari sistem terdistribusi, mencari penyebab utama dari sebuah \textit{outtage} bukanlah sebuah hal yang mudah terlebih jika ada ratusan bahkan ribuan \textit{node} yang terdapat pada \textit{cluster} dan masing-masing \textit{node} saling terhubung dengan yang lainnya. Jika hal semacam tersebut terjadi dalam lingkungan aplikasi \textit{production} maka dampaknya akan terasa langsung oleh pelanggan dan dalam jangka panjang dapat menimbulkan kerugian material. Oleh karena itu, penting untuk segera mengetahui sumber atau akar dari suatu kejadian yang menyebabkan regresi pada performa sistem.

Dari solusi \textit{distributed tracing} bersifat \textit{open source} yang tersedia saat ini, Zipkin dan Jaeger adalah dua solusi \textit{tracing} yang sudah menyediakan komponen instrumentasi, \textit{deployment}, dan \textit{value delivery} dalam bentuk \textit{application programming interface} (API) dan \textit{user interface} secara \textit{default}. Untuk Tugas Akhir ini, penulis akan menganalisis dan membandingkan fitur dari \textit{user interface} berbasis Web yang dimiliki Zipkin dan Jaeger saja. Beberapa fitur yang ada pada \textit{user interface} Zipkin antara lain :
\begin{enumerate}
	\item a 
	\item b
\end{enumerate}
Sementara itu, fitur yang ada pada \textit{user interface} Jaeger antara lain:
\begin{enumerate}
	\item a
	\item b
\end{enumerate}


Berikut adalah tabel perbandingan dari fitur \textit{user interface} web Zipkin dan Jaeger.


\begin{small}
	\begin{longtable}{ | p{4cm} | p{1.5cm} | p{1.5cm} | }
		\caption{Perbandingan fitur \textit{user interface} Zipkin dan Jaeger}
		\label{ui-comparison}                                                                                                                \\ \hline
		\centering\bfseries{Nama Fitur} & \centering\bfseries{Zipkin} & \centering\bfseries{Jaeger} \tabularnewline \hline
		\endfirsthead
		Service Map & \centering{\ding{51}} & \centering\arraybackslash{\ding{51}} \\ \hline
		Root Cause Analysis & \centering{\ding{51}} & \centering\arraybackslash{} \\ \hline
	\end{longtable}
\end{small}


Dari perbandingan fitur di atas, .


%Dari pemaparan mengenai kedua tujuan dari \textit{observability} di atas, penulis menyimpulkan bahwa ada dua hal yang dapat dilakukan oleh \textit{distributed tracing} untuk mencapai kedua tujuan tersebut:
%\begin{enumerate}
%	\item Membuat Service Map untuk mencapai tujuan pertama yaitu meningkatkan performa baseline
%	\item Membuat Root Cause Analyzer (RCA) untuk mencapai tujuan kedua yaitu mengembalikan performa baseline ketika terjadi regresi pada sistem
%\end{enumerate}
%
%Service Map merupakan visualisasi dari sebuah sistem Microservice yang melakukan dekomposisi pada semua komponen \textit{service} dan menggambarkan dependensi yang terlihat antar \textit{service} tersebut secara \textit{real-time}, sehingga \textit{developer} dapat mengidentifikasi \textit{bottleneck} yang ada dan memahami bagaimana data mengalir dalam aristektur \citep{datadog-svcmap}. Untuk dapat membantu meningkatkan performa \textit{baseline}, sebuah Service Map harus dapat menyediakan informasi mengenai hubungan interdependensi antara \textit{service}, jumlah \textit{request} yang diterima oleh service per satuan waktu, dan ukuran performa pada \textit{service} tersebut dalam merespon \textit{service} lainnya. Ukuran performa yang dapat dijadikan \textit{baseline} antara lain adalah \textit{latency}, \textit{failure rate}, \textit{traffic rate}, dan saturasi, namun biasanya \textit{developer} hanya berfokus pada pengukuran \textit{latency} dan \textit{failure rate} \citep{parker2020distributed}.
%
%Selain digunakan untuk mendapatkan gambaran mengenai komponen yang ada pada suatu \textit{cluster} sistem terdistribusi, salah satu teknik yang dapat digunakan oleh Service Map untuk meningkatkan performa \textit{baseline}  disebut \textit{Correlation Analysis}.
%
%
%Di sisi lain, Root Cause Analyzer adalah 






%Untuk mencapai kedua tujuan dari \textit{observability} tersebut, \textit{distributed tracing} dapat digunakan untuk menyediakan hal-hal berikut:
%\begin{enumerate}
%	\item 
%\end{enumerate}



%Seiring dengan meningkatnya penggunaan arsitektur, mengingkat pula kebutuhan bagi para \textit{developer} untuk dapat dengan segera mengetahui sumber dari permasalahan jika terjadi \textit{error} pada sistem.
%
%Dari pemaparan mengenai masih kurangnya kakas visualisasi \textit{tracing} yang bersifat \textit{open source}
%. Berdasarkan studi literatur mengenai \textit{observability} untuk Sistem Terdistribusi pada \ref{bab2-observability}, terdapat 

%Isu visualisasi 
%Overhead


%\section{Analisis Alternatif Solusi}
%Hewo
%
%\section{Rancangan Solusi}
%
%Hewoooo
%
%\section{Rancangan Perhitugan \textit{Overhead}}

%Overhead disini

